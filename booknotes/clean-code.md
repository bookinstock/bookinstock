# 《代码整洁之道》读书笔记

## 前言

### 阅读本书的动机: 想写出干净的代码!

1. **疑问**：如何写出高质量且干净的代码，如何修炼？
2. **答案**：阅读大量的代码，并且琢磨某段代码好在哪坏在哪，多思考，多内省。

### 本书大概分为三个部分：

1. 代码整洁之道的原则，模式，实践。
2. 需要花时间研究的复杂案例，重在理解。
3. 列出2.中案例得到的启示和灵感，回顾总结。

## 第一章：整洁代码

### 要有代码：

> 有人说代码终结的时代即将来临，很快就没有程序员了，商务人士可以通过书写规则直接生成程序。其实并非如此，我们终究是无法舍弃代码的，因为代码呈现了需求的细节，在某些层面这些细节无法被忽略或抽象。实际上，在较高层次上用领域特定语言撰写的规则也是代码，它需要严谨，精确，规范，详细，让机器正确理解执行。如果说需求规约原则教给了我什么，那就是规制良好的需求规则就像代码一样正式，可作为代码的测试来使用。

记住：代码是我们最终用来 **精确** 表达需求的语言。

### 糟糕的代码：

> 1. 我们都曾瞟一眼自己亲手造成的混乱，决定弃之不顾，走向新的一天。
> 2. 我们都曾看到自己写的烂程序居然还能运行，然后笑着对自己说能跑起来的烂程序总比什么都没有强。
> 3. 我们都曾说过有朝一日再回头清理。当然，那些岁月我们没有听过 **勒布朗法则**。

**勒布朗法则**：*Later equals Never.*

### 什么是优雅的代码：

*Bjarne* 的定义：
> 1. 我喜欢**优雅**和**高效**的代码，
> 2. 代码逻辑应当直截了当，叫缺陷难以隐藏；
> 3. 尽量减少依赖关系，使之便于维护；
> 4. 依据某种分层战略完善错误处理代码；
> 5. 性能调优，减少他人优化时带来的其他混乱。

**优雅**：短小精致，让人看着赏心悦目！

**童子军军规**：让营地比你来时更干净，在修改他人代码时同样要牢记。

**破窗理论**：别指望别人会去替你修那扇破窗。简单说就是拉了屎，别指望别人给你擦屁股。
> 窗户破损了的屋子让人觉得似乎无人照管，于是别人也不再关心，他们放任窗户继续破损，最终自己也加入到破坏当中，在墙上涂鸦，堆积垃圾，一扇破损的窗户开辟了大厦走向颓废的道路。

## 第二章：有意义的命名

1. 名副其实：看到名字就知道它是什么，做什么事，该怎么用，无需额外注释。
2. 不要怕：改名可能会使人意外，不过就像做其他修改工作一样，别让这阻碍你前进的脚步。

## 第三章：函数

1. 函数应该尽可能短小。
2. 函数应该只做一件事，做好这件事。
3. 函数名称要花时间仔细考虑，并保持风格统一。
4. 函数要避免出现多个意思模糊且相似的名称。
5. 函数的参数要尽可能少，若大于两个则改为哈希形式。
6. 在特定符合意义的情况下，将参数抽象成类的实例变量。

## 第四章：注释

1. 注释存在的原因是代码表达上的失败。
2. 为什么要极力贬低注释？因为注释会撒谎！
3. 注释存在的时间越久，它距离真相就越遥远。
4. 真相只有一个！真相就是代码本身！

## 第五章：格式

1. 变量和方法的定义要区分开，放在各自特定的位置。
2. 相关函数定义，调用者应该和被调用者放在一起，这样可以一起看。
3. 相关函数定义，被调用者应该放在调用者下方，自上而下的阅读顺序。
4. 团队大于个人，在一个团队中代码应该符合团队所制定的规则。

## 第六章：对象和数据结构

### 公共方法和私有方法：

1. **私有方法**：只在类内部使用，可以放心大胆地去修改私有方法。
2. **公共方法**：尽可能少的暴露公共方法，修改公共方法的成本很高。
3. 公共方法要尽可能抽象，别人只要知道如何使用它，而不关心内部实现。

### 面向过程和面向对象：

1. 面向过程的代码便于在不改动既有数据结构的前提下添加新函数。
2. 面向对象的代码便于在不改动既有函数的前提下添加新的类。
3. 使用多态来代替针对不同类的类型判断，使用鸭子类型来完成更抽象的多态。

### 迪米特法则：

1. 迪米特法则反对链式调用，方法不应该调用任何函数返回的对象的方法。
2. 当函数返回对象的类型始终相同或数据结构非常明确时，迪米特法则失效。

## 第七章：错误处理

1. 经量减少在方法调用时把 NULL 作为参数。
2. 不要把异常作为控制条件判断的手段，将错误处理独立于逻辑判断之外。
3. 自己定义类来封装三方库或API，并自定义异常，减少对特定库或API的依赖。

## 第八章：边界

## 第九章：单元测试

### 写测试的好处：

1. 明确需求。
2. 保证代码的正确性。
3. 出了问题能快速定位。
4. 为重构代码提供保障。

### 较为严格的 TDD 三定律：

1. 先写测试再写代码。
2. 写出刚好无法通过的测试。
3. 写出刚好可以通过测试的代码。
4. 不断循环重复进行以上操作。

### 写出好的测试代码：

1. 脏测试几乎等同于没有测试。
2. 测试代码和生产代码一样重要。
3. 例如：给测试变量起个好名字。
4. 短小精悍，每个测试一个概念。
5. 整洁测试的关键：可读性！

### 测试三步骤：

1. **Build**：构造数据。
2. **Operate**：操作数据。
3. **Check**：验证结果。

### 整洁测试的5条规则 FIRST：

1. **Fast**：测试应该快速运行。
2. **Independent**：测试应该相互独立。
3. **Repeatable**：测试应该可以重复运行。
4. **Self-Validating**：测试应该有真或假输出。
5. **Timely**：测试应该及时编写，越早越好。

## 第十章：类

### 设计原则：

1. 单一职责原则 SRP：创建高内聚的短小精悍类。
2. 开放闭合原则 OCP：类应该对扩展开放对修改封闭。
3. 依赖倒置原则 DIP：类应该依赖于抽象而非具体实现。

### 依赖注入 DI:

1. 目的：为了减少类和类之间的耦合度。
2. 实现：将所依赖的对象作为参数传入而非写死在类内部。
3. 主要好处：不再是依赖于某一具体对象，而是依赖于某一具有特定行为的对象。
4. 其他好处：隔离了依赖对象初始化的过程等。

## 第十一章：系统

1. 系统由不同的扮演特定角色的模块所组成。
2. 模块间的相互调用应简单抽象且清晰明了。

## 第十二章：迭进

1. 写测试
2. 写代码
3. 重构
4. DRY

## 第十三章：并发编程

术语：
1. 限定资源：固定大小或数量的资源，如：数据库链接。
2. 线程互斥：每个时刻仅有一个线程能访问共享数据或资源。
3. 线程饥饿：线程长时间等待或永久被禁止，如：总是让执行快的先运行。
4. 线程死锁：两个线程互相等待执行结果。
5. 线程活锁：线程再启动时相互竞争导致失败。

并发编程原则：
1. 单一职责原则：分离并发代码与业务代码。
2. （推论）限制数据作用域：多线程对同一数据修改时需要进行严格限制。
3. （推论）数据复本：拆分或复制操作数据，多线程处理，单线程合并结果。
4. （推论）尽可能独立：每个线程就像是一个小世界，彼此相互独立。

## 第十四章：逐步改进

## 第十五章：JUnit 内幕

## 第十六章：重构 SerialDate

## 第十七章：味道与启发




